@startuml
''https://plantuml.com/class-diagram
''https://www.youtube.com/watch?v=UI6lqHOVHic

class OCPBuilder{
    - ocp: OptimalControlProblem
    - build_config: BuildConfiguration
    - meta: OptimizerMeta
    - solver_config: SolverConfiguration
    - ocp_build_interface: OcpInterfaceType
    - default_max_outer_iterations: int
    + with_build_config( build_config: BuildConfiguration ): self
    + with_meta( meta: OptimizerMeta ): self
    + with_solver_config( solver_config: SolverConfiguration ): self
    + with_build_interface( ocp_build_interface: OcpInterfaceType ): self
    + with_formulation_type( u_set: Constraint[] ): self
    - build_default_config( void ): void
    + build( void ): void
    - calculate_preconditioning_coefficients( p_val: float[], <<optional>>u_val: float[nu] ): float[]
    - calculate_initial_penalty( u_guess: float[nu], theta_val: float[] )
    - build_with_updated_penalty( ocp_solve_fn: void, p_init: float[] )
    + solve( p_init: float[], <<optional>>print_result: bool ): float[]
}

interface system_interface {
    sys_dyn_fn( x: SX[nx], u: SX[nu], p_symb: SX[] ) : SX[nx] (next_state)
    stage_cost_fn( x: SX[nx], u: SX[nu], p_symb: SX[] ) : SX (stage_cost)
    terminal_cost_fn( x: SX[nx], p_symb: SX[] ) : SX (terminal_cost)
}

enum OcpInterfaceType {
DIRECT
TCP
}
OcpInterfaceType <|-l- OCPBuilder
OcpInterfaceType <|-u[hidden]- ExclusionSet

class formulations <<static functions>>{
    single_shooting_formulation( ocp: OptimalControlProblem, x: SX[], u: SX[], p: SX[] ): cost, decision_var, bounds, alm_constraints, alm_set, pm_constraints
    multiple_shooting_formulation( ocp: OptimalControlProblem, x: SX[], u: SX[], p: SX[] ): cost, decision_var, bounds, alm_constraints, alm_set, pm_constraints
}
formulations <|-u[hidden]- OcpInterfaceType

formulations <|-l- OCPBuilder

class solver_interface <<static functions>>{
    direct_interface()
    tcp_interface()
}

solver_interface <|-r[hidden]- formulations
solver_interface <|- OCPBuilder

class OptimalControlProblem{
    - p_symb: SX[]
    - nx: int
    - nu: int
    - horizon: int
    - x_set: Constraint[]
    - u_set: Constraint[]
    - formulation_type: FormulationType
    - exclusion_set: ExclusionSet[]
    - problem: Problem
    - sys_dyn_fn: void*
    - stage_cost_fn: void*
    - terminal_cost_fn: void*
    + with_hotizon( horizon: int )
    + with_state_constraint( x_set: Constraint[] ): self
    + with_input_constraint( u_set: Constraint[] ): self
    + with_formulation_type( u_set: Constraint[] ): self
    + with_exclusion_set( exclusion_set: Constraint[] ): self
    + save_OCP(problem: Problem): self
    + get_nx(): int
    + get_nu(): int
    + get_horizon(): int
    + get_p_symb(): SX[]
    + get_x_set(): Constraint[]
    + get_u_set(): Constraint[]
    + get_formulation_type(): FormulationType
    + get_exclusion_set(): Constraint[]
    + get_problem(): Problem
}

system_interface <|-r- OptimalControlProblem
OptimalControlProblem <|-r- OCPBuilder

enum FormulationType {
SINGLE_SHOOTING
MULTIPLE_SHOOTING
}
FormulationType <|-d- OptimalControlProblem

class ExclusionSet{
    - constraint: Constraint
    - state_idx
    - mode: ConstraintMethod
    + get_exclusion_mode(): ConstraintMethod
    + exclude_set( x: SX[], nx: int, horizon: int ): SX[]
}
ExclusionSet <|-u- OptimalControlProblem

enum ConstraintMethod {
ALM
PM
}
ConstraintMethod <|-u- ExclusionSet


opengen.constraints.Constraint<|-u- OptimalControlProblem
opengen.constraints.Constraint<|-- OCPBuilder
opengen.constraints.Constraint<|-- ExclusionSet
opengen.config.SolverConfiguration<|-- OCPBuilder
opengen.config.BuildConfiguration<|- OCPBuilder
opengen.config.OptimizerMeta<|- OCPBuilder
opengen.builder.Problem<|- OptimalControlProblem
opengen.builder.Problem<|-d[hidden]- opengen.config.OptimizerMeta
system_interface<|-d[hidden]- opengen.builder.Problem
@enduml