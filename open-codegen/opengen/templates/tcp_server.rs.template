use optimization_engine::continuation::HomotopySolverStatus;
use serde::{Deserialize, Serialize};
use std::{
    io::{prelude::Read, Write},
    net::TcpListener,
};
use {{ meta.optimizer_name }}::*;

extern crate pretty_env_logger;
#[macro_use]
extern crate log;

const BIND_IP: &str = "{{tcp_server_config.bind_ip}}";
const BIND_PORT: i32 = {{tcp_server_config.bind_port}};

#[derive(Deserialize, Debug)]
struct ExecutionParameter {
    parameter: Option<Vec<f64>>,
}

/// Request from the client
#[derive(Deserialize, Debug)]
enum ClientRequest {
    Run(ExecutionParameter),
    Kill(i32),
}

/// Solution and solution status of optimizer
#[derive(Serialize, Debug)]
struct OptimizerSolution<'a> {
    exit_status: String,
    num_outer_iterations: usize,
    num_inner_iterations: usize,
    last_problem_norm_fpr: f64,
    max_constraint_violation: f64,
    solve_time_ms: f64,
    solution: &'a [f64],
}

/// Writes an error to the communication stream
fn write_error(stream: &mut std::net::TcpStream, code: i32) {
    let error_message = format!(
        {% raw %}"{{\n\t\"Error\" : \"Invalid Request\"\n\t\"Code\" : {}\n}}\n"{% endraw %},
        code
    );
    stream
        .write(error_message.as_bytes())
        .expect("cannot write to stream");
}

/// Serializes the solution and solution status and returns it
/// to the client
fn return_solution_to_client(
    status: HomotopySolverStatus,
    solution: &[f64],
    stream: &mut std::net::TcpStream,
) {
    let solution: OptimizerSolution = OptimizerSolution {
        exit_status: format!("{:?}", status.exit_status()),
        num_outer_iterations: status.num_outer_iterations(),
        num_inner_iterations: status.num_inner_iterations(),
        last_problem_norm_fpr: status.last_problem_norm_fpr(),
        max_constraint_violation: status.max_constraint_violation(),
        solve_time_ms: (status.solve_time().as_nanos() as f64) / 1e6,
        solution: solution,
    };
    let solution_json = serde_json::to_string_pretty(&solution).unwrap();
    stream
        .write(solution_json.as_bytes())
        .expect("cannot write to stream");
}

/// Handles an execution request
fn execution_handler(
    cache: &mut optimization_engine::core::panoc::PANOCCache,
    execution_parameter: &ExecutionParameter,
    u: &mut [f64],
    p: &mut [f64],
    stream: &mut std::net::TcpStream,
) {
    let parameter = &execution_parameter.parameter;
    match parameter {
        Some(parameter_value) => {
            p.copy_from_slice(&parameter_value);
            let status = solve(&p, cache, u);
            match status {
                Ok(ok_status) => {
                    return_solution_to_client(ok_status, u, stream);
                }
                Err(_) => {
                    warn!("Invalid Request: Error 2000");
                    write_error(stream, 2000);
                }
            }
        }
        None => {
            warn!("Invalid Request: Error 1001");
            write_error(stream, 1001);
        }
    }
}

fn run_server() {
    pretty_env_logger::init();
    info!("Initializing cache...");
    let mut p = [0.0; NP];
    let mut cache = initialize_solver();
    info!("Done");
    let listener = TcpListener::bind(format!("{}:{}", BIND_IP, BIND_PORT)).unwrap();
    let mut u = [-1.0, -1.0, -1.0, -1.0, 0.0];
    info!("listening started, ready to accept");
    for stream in listener.incoming() {
        let mut stream = stream.unwrap();

        let mut buffer = String::new();
        stream.read_to_string(&mut buffer).expect("can't read stream");

        let received_request: serde_json::Result<ClientRequest> = serde_json::from_str(&buffer);

        match received_request {
            Ok(request_content) => match request_content {
                ClientRequest::Run(param) => {
                    trace!("Running solver");
                    execution_handler(&mut cache, &param, &mut u, &mut p, &mut stream);
                }
                ClientRequest::Kill(_) => {
                    info!("Quitting on request");
                    break;
                }
            },
            Err(_) => {
                warn!("Invalid Request: Error 1000");
                write_error(&mut stream, 1000);
            }
        }
    }
}
fn main() {
    run_server();
    info!("Exiting... (adios!)");
}
