/*
 * Interface/Wrapper for C functions generated by CasADi
 *
 * CasADi generated the following four files:
 * - auto_casadi_cost.c
 * - auto_casadi_grad.c
 * - auto_casadi_mapping_f1.c
 * - auto_casadi_mapping_f2.c
 *
 * This file is autogenerated by Optimization Engine
 * See http://doc.optimization-engine.xyz
 *
 *
 * Metadata:
 * + Optimizer
 *   + name: {{ meta.optimizer_name }}
 *   + version: {{ meta.version }}
 *   + licence: {{ meta.licence }}
 * + Problem
 *   + vars: {{ problem.dim_decision_variables() }}
 *   + parameters: {{ problem.dim_parameters() }}
 *   + n1: {{ problem.dim_constraints_aug_lagrangian() }}
 *   + n2: {{ problem.dim_constraints_penalty() }}
 *
 * Generated at: {{timestamp_created}}
 *
 */
#include <stdlib.h>
#include <string.h>

#define TRUE 1
#define FALSE 0

#define NU {{ problem.dim_decision_variables() }}
#define NP {{ problem.dim_parameters() + problem.dim_constraints_penalty() }}

/* 
 * TODO: This is a temporary solution; we need to get the exact value 
 *       from Python using cs.Function.sz_arg() !
 */
#define MAX_ARG {{ 1 + problem.dim_decision_variables()
                     + problem.dim_parameters()
                     + problem.dim_constraints_aug_lagrangian()
                     + problem.dim_constraints_penalty() }}

#ifndef casadi_real
#define casadi_real double
#endif

#ifndef casadi_int
#define casadi_int long long int
#endif

/*
 * CasADi interface for the cost function
 * and its workspace sizes
 */
extern int {{build_config.cost_function_name or 'phi'}}_work(
    casadi_int *sz_arg,
    casadi_int *sz_res,
    casadi_int *sz_iw,
    casadi_int *sz_w);
extern int {{build_config.cost_function_name or 'phi'}}(
    const casadi_real** arg, 
    casadi_real** res, 
    casadi_int* iw, 
    casadi_real* w, 
    void* mem);

/*
 * CasADi interface for the gradient of the cost
 * and its workspace sizes
 */
extern int {{build_config.grad_function_name  or 'grad_phi'}}_work(
    casadi_int *sz_arg,
    casadi_int *sz_res,
    casadi_int *sz_iw,
    casadi_int *sz_w);
extern int {{build_config.grad_function_name  or 'grad_phi'}}(
    const casadi_real** arg, 
    casadi_real** res, 
    casadi_int* iw, 
    casadi_real* w, 
    void* mem);

/*
 * CasADi interface for the gradient of mapping F1
 * and its workspace sizes
 */
extern int {{build_config.alm_mapping_f1_function_name}}_work(
    casadi_int *sz_arg,
    casadi_int *sz_res,
    casadi_int *sz_iw,
    casadi_int *sz_w);

/*
 * CasADi interface for the gradient of mapping F2
 * and its workspace sizes
 */
extern int {{build_config.constraint_penalty_function_name}}_work(
    casadi_int *sz_arg,
    casadi_int *sz_res,
    casadi_int *sz_iw,
    casadi_int *sz_w);


/* Whether memory has been previously allocated */
static char is_allocated = FALSE;

/*
 * ALLOCATED MEMORY
 */

/* Integer workspaces */
static casadi_int *allocated_i_workspace_cost = NULL;   /* cost (int ) */
static casadi_int *allocated_i_workspace_grad = NULL;   /* grad (int ) */
static casadi_int *allocated_i_workspace_f1 = NULL;     /* F1   (int ) */
static casadi_int *allocated_i_workspace_f2 = NULL;     /* F2   (int ) */

/* Real workspaces */
static casadi_real *allocated_r_workspace_cost = NULL;  /* cost (real) */
static casadi_real *allocated_r_workspace_grad = NULL;  /* grad (real) */
static casadi_real *allocated_r_workspace_f1 = NULL;    /* F1   (real) */
static casadi_real *allocated_r_workspace_f2 = NULL;    /* F2   (real) */

/* Result workspaces */
static casadi_real **result_space_cost = NULL;          /* cost (real) */
static casadi_real **result_space_grad = NULL;          /* grad (real) */
static casadi_real **result_space_f1 = NULL;            /* F1   (real) */
static casadi_real **result_space_f2 = NULL;            /* F2   (real) */

/**
 * Allocates memory only the first time it is called
 * Returns 0 if the allocation of memory was successful 
 */
static int allocate_if_not_yet() {

    /* Sizes for cost function */
    casadi_int sz_arg_cost = 0;
    casadi_int sz_res_cost = 0;
    casadi_int sz_iw_cost = 0;
    casadi_int sz_w_cost = 0;

    /* Sizes for gradient */
    casadi_int sz_arg_grad = 0;
    casadi_int sz_res_grad = 0;
    casadi_int sz_iw_grad = 0;
    casadi_int sz_w_grad = 0;

    /* Sizes for F1 */
    casadi_int sz_arg_f1 = 0;
    casadi_int sz_res_f1 = 0;
    casadi_int sz_iw_f1 = 0;
    casadi_int sz_w_f1 = 0;

    /* Sizes for F2 */
    casadi_int sz_arg_f2 = 0;
    casadi_int sz_res_f2 = 0;
    casadi_int sz_iw_f2 = 0;
    casadi_int sz_w_f2 = 0;

    if (is_allocated) return 0;

    /* Obtain sizes */
    {{build_config.cost_function_name or 'phi'}}_work(
        &sz_arg_cost, 
        &sz_res_cost, 
        &sz_iw_cost, 
        &sz_w_cost);
    {{build_config.grad_function_name  or 'grad_phi'}}_work(
        &sz_arg_grad, 
        &sz_res_grad, 
        &sz_iw_grad, 
        &sz_w_grad);
    {{build_config.alm_mapping_f1_function_name}}_work(
        &sz_arg_f1, 
        &sz_res_f1, 
        &sz_iw_f1, 
        &sz_w_f1);
    {{build_config.constraint_penalty_function_name}}_work(
        &sz_arg_f2, 
        &sz_res_f2, 
        &sz_iw_f2, 
        &sz_w_f2);


    /*
     * Allocate memory (if not allocated previously)
     */

    /* Allocate memory for cost function */
    allocated_i_workspace_cost = (casadi_int*)malloc(sz_iw_cost*sizeof(casadi_int));   /* int work        */
    if (sz_iw_cost > 0 && allocated_i_workspace_cost == NULL) goto fail_1;             /* int work fail   */
    allocated_r_workspace_cost = (casadi_real*)malloc(sz_w_cost*sizeof(casadi_real));  /* work            */
    if (sz_w_cost > 0 && allocated_r_workspace_cost == NULL) goto fail_2;              /* work fail       */

    /* Allocate memory for gradient */
    allocated_i_workspace_grad = (casadi_int*)malloc(sz_iw_grad*sizeof(casadi_int));   /* int work        */
    if (sz_iw_grad > 0 && allocated_i_workspace_grad == NULL) goto fail_3;             /* int work fail   */
    allocated_r_workspace_grad = (casadi_real*)malloc(sz_w_grad*sizeof(casadi_real));  /* work            */
    if (sz_w_grad > 0 && allocated_r_workspace_grad == NULL) goto fail_4;              /* work fail       */

    /* Allocate memory for F1 */
    allocated_i_workspace_f1 = (casadi_int*)malloc(sz_iw_f1*sizeof(casadi_int));       /* int work        */
    if (sz_iw_f1 > 0 && allocated_i_workspace_f1 == NULL) goto fail_5;                 /* int work fail   */
    allocated_r_workspace_f1 = (casadi_real*)malloc(sz_w_f1*sizeof(casadi_real));      /* work            */
    if (sz_w_f1 > 0 && allocated_r_workspace_f1 == NULL) goto fail_6;                  /* work fail       */

    /* Allocate memory for F2 */
    allocated_i_workspace_f2 = (casadi_int*)malloc(sz_iw_f2*sizeof(casadi_int));       /* int work        */
    if (sz_iw_f2 > 0 && allocated_i_workspace_f2 == NULL) goto fail_7;                 /* int work fail   */
    allocated_r_workspace_f2 = (casadi_real*)malloc(sz_w_f2*sizeof(casadi_real));      /* work            */
    if (sz_w_f2 > 0 && allocated_r_workspace_f2 == NULL) goto fail_8;                  /* work fail       */

    /* Allocate memory for result spaces */
    result_space_cost = (casadi_real**)malloc((sz_res_cost)*sizeof(casadi_real*));     /* res space: cost */
    if (sz_res_cost > 0 && result_space_cost == NULL) goto fail_9;                     /* res space fail  */
    result_space_grad = (casadi_real**)malloc((sz_res_grad)*sizeof(casadi_real*));     /* res space: grad */
    if (sz_res_grad > 0 && result_space_grad == NULL) goto fail_10;                    /* res space fail  */

    /* All memory has been allocated; it shouldn't be re-allocated */
    is_allocated = TRUE;

    return 0;

    /* Free memory that has been previously allocated (failure!) */
    fail_10:
        free(result_space_cost);
    fail_9:
        free(allocated_r_workspace_f2);
    fail_8:
        free(allocated_i_workspace_f2);
    fail_7:
        free(allocated_r_workspace_f1);
    fail_6:
        free(allocated_i_workspace_f1);
    fail_5:
        free(allocated_r_workspace_grad);
    fail_4:
        free(allocated_i_workspace_grad);
    fail_3:
        free(allocated_r_workspace_cost);
    fail_2:
        free(allocated_i_workspace_cost);
    fail_1:
        return 1;
}

/** 
 * Initialise the memory
 */
int init_{{build_config.id or '0'}}() {
	/* The first time we call this method, it will allocate memory */
	if (!is_allocated){
	  return allocate_if_not_yet();
	}
	/* Otherwise, it will do nothing and will return 0 (success) */
	return 0;
}

/** 
 * Destroy all allocated memory
 */
int destroy_{{build_config.id or '0'}}() {
	/* If no memory has been allocated, return 0 (success) */
	if (!is_allocated) return 0;
	if (allocated_i_workspace_cost != NULL) free(allocated_i_workspace_cost);
	if (allocated_r_workspace_cost != NULL) free(allocated_r_workspace_cost);
	if (allocated_i_workspace_grad != NULL) free(allocated_i_workspace_grad);
	if (allocated_r_workspace_grad != NULL) free(allocated_r_workspace_grad);
	if (allocated_i_workspace_f1 != NULL) free(allocated_i_workspace_f1);
	if (allocated_r_workspace_f1 != NULL) free(allocated_r_workspace_f1);
	if (allocated_i_workspace_f2 != NULL) free(allocated_i_workspace_f2);
	if (allocated_r_workspace_f2 != NULL) free(allocated_r_workspace_f2);

	return 0;
}



/* ------U, P------------------------------------------------------------------- */
static casadi_real up_space[NU+NP];

static void copy_args_into_up_space(const casadi_real** arg) {
    int i;
    for (i=0; i<NU; i++) up_space[i] = arg[0][i];
    for (i=0; i<NP; i++) up_space[NU+i] = arg[1][i];
}

/* ------COST------------------------------------------------------------------- */



/* Cost function main interface */
int cost_function(const casadi_real** arg, casadi_real** res) {
    const casadi_real* args__[MAX_ARG] = {up_space, up_space + NU};
    copy_args_into_up_space(arg);
    
    allocate_if_not_yet();
    const casadi_real* arguments_[100] = {arg[0], arg[1]};
    result_space_cost[0] = res[0];
    return {{build_config.cost_function_name or 'phi'}}(
        args__, 
        result_space_cost, 
        allocated_i_workspace_cost, 
        allocated_r_workspace_cost, 
        (void*) 0);
}


/* ------GRADIENT--------------------------------------------------------------- */

/* Cost function main interface */
int grad_cost_function(const casadi_real** arg, casadi_real** res) {
    allocate_if_not_yet();
    const casadi_real* arguments_[100] = {arg[0], arg[1]};
    result_space_cost[0] = res[0];
    return {{build_config.grad_function_name  or 'grad_phi'}}(
        arguments_, 
        result_space_cost, 
        allocated_i_workspace_cost, 
        allocated_r_workspace_cost, 
        (void*) 0);
}


/** 
 * Integer-type workspace for GRADient
 */
casadi_int * allocated_{{build_config.grad_function_name  or 'grad_phi'}}_iwork() {
	allocate_if_not_yet();
	return allocated_i_workspace_grad;
}

/** 
 * Real-type workspace for GRADient
 */
casadi_real * allocated_{{build_config.grad_function_name  or 'grad_phi'}}_rwork() {
	allocate_if_not_yet();
	return allocated_r_workspace_grad;
}


/* ------MAPPING F1------------------------------------------------------------- */

/** 
 * Integer-type workspace for F1
 */
casadi_int * allocated_{{build_config.alm_mapping_f1_function_name}}_iwork() {
	allocate_if_not_yet();
	return allocated_i_workspace_f1;
}

/** 
 * Real-type workspace for F1
 */
casadi_real * allocated_{{build_config.alm_mapping_f1_function_name}}_rwork() {
	allocate_if_not_yet();
	return allocated_r_workspace_f1;
}


/* ------MAPPING F2------------------------------------------------------------- */

/** 
 * Integer-type workspace for F2
 */
casadi_int * allocated_{{build_config.constraint_penalty_function_name}}_iwork() {
	allocate_if_not_yet();
	return allocated_i_workspace_f2;
}

/** 
 * Real-type workspace for F2
 */
casadi_real * allocated_{{build_config.constraint_penalty_function_name}}_rwork() {
	allocate_if_not_yet();
	return allocated_r_workspace_f2;
}
