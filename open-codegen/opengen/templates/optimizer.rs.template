//
// Auto-generated file by OptimizationEngine
// See https://alphaville.github.io/optimization-engine/
//
// Generated at: {{timestamp_created}}
//

use icasadi;
{% if activate_clib_generation -%}
use libc::{c_double, c_ulong, c_ulonglong};
use optimization_engine::continuation::HomotopyCache;
{% endif %}
use optimization_engine::{constraints::*, panoc::*, alm::*, *};

// ---Private Constants----------------------------------------------------------------------------------

/// Tolerance of inner solver
const EPSILON_TOLERANCE: f64 = {{solver_config.tolerance or 0.0001}};

/// Delta tolerance
const DELTA_TOLERANCE: f64 = {{solver_config.constraints_tolerance or 0.0001}};

/// LBFGS memory
const LBFGS_MEMORY: usize = {{solver_config.lbfgs_memory or 10}};

/// Maximum number of iterations of the inner solver
const MAX_INNER_ITERATIONS: usize = {{solver_config.max_inner_iterations or 10000}};

/// Maximum number of outer iterations
const MAX_OUTER_ITERATIONS: usize = {{solver_config.max_outer_iterations or 10}};

/// Maximum execution duration in microseconds
const MAX_DURATION_MICROS: u64 = {{solver_config.max_duration_micros}};



// ---Public Constants-----------------------------------------------------------------------------------

/// Number of decision variables
pub const {{meta.optimizer_name|upper}}_NUM_DECISION_VARIABLES: usize = {{problem.dim_decision_variables()}};

/// Number of parameters
pub const {{meta.optimizer_name|upper}}_NUM_PARAMETERS: usize = {{problem.dim_parameters()}};

/// Number of parameters associated with augmented Lagrangian
pub const {{meta.optimizer_name|upper}}_N1: usize = {{problem.dim_constraints_aug_lagrangian()}};

/// Number of penalty constraints
pub const {{meta.optimizer_name|upper}}_N2: usize = {{problem.dim_constraints_penalty() or 0}};

{#- THIS WAY WE CAN INCLUDE ANOTHER TEMPLATE -#}
{% include "optimizer_cinterface.rs.template" %}


// ---Parameters of the constraints----------------------------------------------------------------------

{% if 'Ball2' == problem.constraints.__class__.__name__ or 'BallInf' == problem.constraints.__class__.__name__ -%}
/// Constraints: Centre of Euclidean Ball
const CONSTRAINTS_BALL_XC: Option<&[f64]> = {% if problem.constraints.center is not none %}Some(&[{{problem.constraints.center | join(', ')}}]){% else %}None{% endif %};
/// Constraints: Radius of Euclidean Ball
const CONSTRAINTS_BALL_RADIUS : f64 = {{problem.constraints.radius}};
{% elif 'Rectangle' == problem.constraints.__class__.__name__ -%}
const CONSTRAINTS_XMIN :Option<&[f64]> = {% if problem.constraints.xmin is not none %}Some(&[{{problem.constraints.xmin|join(', ')}}]){% else %}None{% endif %};
const CONSTRAINTS_XMAX :Option<&[f64]> = {% if problem.constraints.xmax is not none %}Some(&[{{problem.constraints.xmax|join(', ')}}]){% else %}None{% endif %};
{% endif %}



// ---Parameters of ALM-type constraints (Set C)---------------------------------------------------------

{% if problem.alm_set_c is not none %}
{% if 'Ball2' == problem.alm_set_c.__class__.__name__ or 'BallInf' == problem.alm_set_c.__class__.__name__ -%}
/// Constraints: Centre of Euclidean Ball
const SET_C_BALL_XC: Option<&[f64]> = {% if problem.alm_set_c.center is not none %}Some(&[{{problem.alm_set_c.center | join(', ')}}]){% else %}None{% endif %};
/// Constraints: Radius of Euclidean Ball
const SET_C_CONSTRAINTS_BALL_RADIUS : f64 = {{problem.alm_set_c.radius}};
{% elif 'Rectangle' == problem.alm_set_c.__class__.__name__ -%}
const SET_C_CONSTRAINTS_XMIN :Option<&[f64]> = {% if problem.alm_set_c.xmin is not none %}Some(&[{{problem.alm_set_c.xmin|join(', ')}}]){% else %}None{% endif %};
const SET_C_CONSTRAINTS_XMAX :Option<&[f64]> = {% if problem.alm_set_c.xmax is not none %}Some(&[{{problem.alm_set_c.xmax|join(', ')}}]){% else %}None{% endif %};
{% endif %}
{% endif %}


// ---Internal private helper functions------------------------------------------------------------------

fn make_constraints() -> impl Constraint {
    {% if 'Ball2' == problem.constraints.__class__.__name__ -%}
    let bounds = Ball2::new(CONSTRAINTS_BALL_XC, CONSTRAINTS_BALL_RADIUS);
    {% elif 'BallInf' == problem.constraints.__class__.__name__ -%}
    let bounds = Ball2::new(CONSTRAINTS_BALL_XC, CONSTRAINTS_BALL_RADIUS);
    {% elif 'Rectangle' == problem.constraints.__class__.__name__ -%}
    let bounds = Rectangle::new(CONSTRAINTS_XMIN, CONSTRAINTS_XMAX);
    {% elif 'NoConstraints' == problem.constraints.__class__.__name__ -%}
    let bounds = NoConstraints::new();
    {% endif -%}
    bounds
}

{% if problem.alm_set_c is not none %}
fn make_set_c() -> impl Constraint {
    {% if 'Ball2' == problem.constraints.__class__.__name__ -%}
    let set_c = Ball2::new(CONSTRAINTS_BALL_XC, CONSTRAINTS_BALL_RADIUS);
    {% elif 'BallInf' == problem.constraints.__class__.__name__ -%}
    let set_c = Ball2::new(CONSTRAINTS_BALL_XC, CONSTRAINTS_BALL_RADIUS);
    {% elif 'Rectangle' == problem.constraints.__class__.__name__ -%}
    let set_c = Rectangle::new(CONSTRAINTS_XMIN, CONSTRAINTS_XMAX);
    {% elif 'NoConstraints' == problem.constraints.__class__.__name__ -%}
    let set_c = NoConstraints::new();
    {% endif -%}
    set_c
}
{% endif %}

// ---Main public API functions--------------------------------------------------------------------------


/// Initialisation of the solver
pub fn initialize_solver() -> AlmCache {
    let panoc_cache = PANOCCache::new({{meta.optimizer_name|upper}}_NUM_DECISION_VARIABLES, EPSILON_TOLERANCE, LBFGS_MEMORY);
    {% if solver_config.cbfgs_alpha is not none and solver_config.cbfgs_epsilon is not none -%}
        let panoc_cache = panoc_cache.with_cbfgs_parameters({{solver_config.cbfgs_alpha}}, {{solver_config.cbfgs_epsilon}}, {{solver_config.cbfgs_sy_epsilon}});
    {% endif -%}
    let alm_cache = AlmCache::new(panoc_cache, {{meta.optimizer_name|upper}}_N1, {{meta.optimizer_name|upper}}_N2);

    alm_cache
}


/// Solver interface
pub fn solve(
    p: &[f64],
    alm_cache: &mut AlmCache,
    u: &mut [f64],
) -> Result<AlmOptimizerStatus, SolverError> {

    assert_eq!(p.len(), {{meta.optimizer_name|upper}}_NUM_PARAMETERS, "Wrong number of parameters (p)");
    assert_eq!(u.len(), {{meta.optimizer_name|upper}}_NUM_DECISION_VARIABLES, "Wrong number of decision variables (u)");

    let psi = |u: &[f64], xi: &[f64], cost: &mut f64| -> Result<(), SolverError> {
        icasadi::cost(&u, &xi, &p, cost);
        Ok(())
    };
    let grad_psi = |u: &[f64], xi: &[f64], grad: &mut [f64]| -> Result<(), SolverError> {
        icasadi::grad(&u, &xi, &p, grad);
        Ok(())
    };
    {% if problem.dim_constraints_aug_lagrangian() > 0 %}
    let f1 = |u: &[f64], res: &mut [f64]| -> Result<(), SolverError> {
        icasadi::mapping_f1(&u, &p, res);
        Ok(())
    };{% endif %}
    {% if problem.dim_constraints_penalty() %}let f2 = |u: &[f64], res: &mut [f64]| -> Result<(), SolverError> {
        icasadi::mapping_f2(&u, &p, res);
        Ok(())
    };{% endif -%}
    let bounds = make_constraints();

    {% if problem.dim_constraints_aug_lagrangian() > 0 -%}
    let set_y = Ball2::new(None, 10000.0);
    let set_c = make_set_c();
    {% endif -%}

    let alm_problem = AlmProblem::new(
        bounds,
        {% if problem.dim_constraints_aug_lagrangian() > 0 %}Some(set_c){% else %}NO_SET{% endif %},
        {% if problem.dim_constraints_aug_lagrangian() > 0 %}Some(set_y){% else %}NO_SET{% endif %},
        psi,
        grad_psi,
        {% if problem.dim_constraints_aug_lagrangian() > 0 %}Some(f1){% else %}NO_MAPPING{% endif %},
        {% if problem.dim_constraints_penalty() %}Some(f2){% else %}NO_MAPPING{% endif %},
        {{meta.optimizer_name|upper}}_N1,
        {{meta.optimizer_name|upper}}_N2,
    );

    let mut alm_optimizer = AlmOptimizer::new(alm_cache, alm_problem)
        .with_delta_tolerance(DELTA_TOLERANCE)
        .with_epsilon_tolerance(EPSILON_TOLERANCE)
        .with_initial_inner_tolerance(EPSILON_TOLERANCE)
        .with_max_duration(std::time::Duration::from_micros(MAX_DURATION_MICROS))
        .with_max_outer_iterations(MAX_OUTER_ITERATIONS)
        .with_max_inner_iterations(MAX_INNER_ITERATIONS);

    // solve the problem using `u` an the initial condition
    // return the problem status (instance of `AlmOptimizerStatus`)
    alm_optimizer.solve(u)
}
