/*
 * Auto-generated file by OptimizationEngine
 * See https://alphaville.github.io/optimization-engine/
 *
 * Generated at: {{timestamp_created}}
 */
#![allow(unused_attributes,dead_code,unused_imports)]

extern crate optimization_engine;

use icasadi;
use optimization_engine::{constraints::*, panoc::*, *};
use std::{num::NonZeroUsize, slice, time};

const TOLERANCE: f64 = {{solver_config.tolerance() or 0.0001}};
const LBFGS_MEMORY: usize = {{solver_config.lbfgs_memory() or 10}};
const MAX_ITERS: usize = {{solver_config.max_iterations() or 2000}};
const NU: usize = {{problem.dim_decision_variables()}};
const NP: usize = {{problem.dim_parameters()}};
const NCP: usize = {{problem.dim_constraints_penalty()}};
const NCAL: usize = {{problem.dim_constraints_aug_lagrangian()}};
{% if 'Ball2' == problem.constraints().__class__.__name__ and problem.constraints().center() is not none -%}
const XC: [f64; {{problem.dim_decision_variables()}}] = [{{problem.constraints().center()|join(', ')}}];
{%- elif 'Rectangle' == problem.constraints().__class__.__name__ -%}
{%- if problem.constraints().xmin is not none -%}
const XMIN :Option<&[f64]> = Some(&[{{problem.constraints().xmin|join(', ')}}]);
{%- else -%}
const XMIN :Option<&[f64]> = None;
{%- endif -%}
{% if problem.constraints().xmax is not none %}
const XMAX :Option<&[f64]> = Some(&[{{problem.constraints().xmax|join(', ')}}]);
{%- else -%}
const XMAX :Option<&[f64]> = None;
{% endif %}
{%- endif %}


pub fn initialize_solver() -> PANOCCache {
    let problem_size = NonZeroUsize::new(NU).unwrap();
    let lbfgs_memory_size = NonZeroUsize::new(LBFGS_MEMORY).unwrap();
    let panoc_cache = PANOCCache::new(problem_size, TOLERANCE, lbfgs_memory_size);

    panoc_cache
}


// -- work in progress --
pub fn solve(p: &[f64], cache: &mut PANOCCache, u: &mut [f64]) -> Result<(), Error> {
	//TODO: better error management (in closures)

	/* cost function, f(u; q) */
    let cost_function = |u: &[f64], q: &[f64], cost: &mut f64| -> Result<(), Error> {
        icasadi::icasadi_cost(u, q, cost);
        Ok(())
    };

    /* parametric gradient, df(u, q) */
    let gradient_function = |u: &[f64], q: &[f64], grad: &mut [f64]| -> Result<(), Error> {
        icasadi::icasadi_grad(u, q, grad);
        Ok(())
    };

	/* penalty-type constraints: c(u; p) */
    let penalty_constr_function =
    |u: &[f64], q: &[f64], constraints: &mut [f64]| -> Result<(), Error> {
        icasadi::icasadi_constraints_as_penalty(u, q, constraints);
        Ok(())
    };


    //Constraints...
{%- if problem.constraints() is none %}
    let bounds = NoConstraints::new();
{%- elif 'Ball2' == problem.constraints().__class__.__name__ %}
{%- if problem.constraints().center() is none %}
	let bounds = Ball2::new(None, {{problem.constraints().radius()}});
{%- else %}
	let bounds = Ball2::new(Some(&XC), {{problem.constraints().radius()}});
{%- endif %}
{%- elif 'Rectangle' == problem.constraints().__class__.__name__ %}
    let bounds = Rectangle::new(XMIN, XMAX);
{%- endif %}


    // Define homotopy problem
    //TODO: This constructor may not need to know NP...
    let mut homotopy_problem = continuation::HomotopyProblem::new(
        bounds,
        gradient_function,
        cost_function,
        penalty_constr_function,
        NP,
    );

    // Do the following, only if there are some penalty-type constraints,
    // otherwise skip it
    if NCP > 0 {
        let idx_y: Vec<usize> = (NP+1..=NP+NCP).collect();
        homotopy_problem.add_continuations(
            &idx_y[..],
            &[1.; 2],
            &[1000.; 2],
            &[continuation::ContinuationMode::Geometric(5.0); 2],
        );
    }

    let mut homotopy_optimizer = continuation::HomotopyOptimizer::new(&homotopy_problem, cache);

    //TODO: Here, instead of `p`, we need to provide `q`, which need to
    //be properly initialised as `q = [p, y0]`, with `p` being the given
    //parameter and `y0`. We can provide `y0` to be ANYTHING. Its actual
    //initial value will be set inside HomotopyOptimizer by the private
    //method `initialize_param`.
    homotopy_optimizer.solve(u, p)
}
