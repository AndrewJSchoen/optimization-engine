/*
 * Auto-generated file by OptimizationEngine
 * See https://alphaville.github.io/optimization-engine/
 *
 * Generated at: {{timestamp_created}}
 */
#![allow(unused_attributes,dead_code,unused_imports)]

extern crate optimization_engine;

use icasadi;
use optimization_engine::{constraints::*, panoc::*, *};
use std::{num::NonZeroUsize, slice, time};

const TOLERANCE: f64 = {{solver_config.tolerance() or 0.0001}};
const LBFGS_MEMORY: usize = {{solver_config.lbfgs_memory() or 10}};
const MAX_ITERS: usize = {{solver_config.max_iterations() or 2000}};
const NU: usize = {{problem.dim_decision_variables()}};
const NP: usize = {{problem.dim_parameters()}};
const NCP: usize = {{problem.dim_constraints_penalty()}};
const NCAL: usize = {{problem.dim_constraints_aug_lagrangian()}};
const CONSTRAINTS_TOLERANCE: f64 = {{solver_config.constraints_tolerance() or 0.0001}};
const MAX_OUTER_ITERATIONS: usize = {{solver_config.max_outer_iterations() or 10}};
const PENALTY_WEIGHT_UPDATE_FACTOR: f64 = {{solver_config.penalty_weight_update_factor() or 5.0}};
{% if 'Ball2' == problem.constraints().__class__.__name__ and problem.constraints().center() is not none -%}
const XC: [f64; {{problem.dim_decision_variables()}}] = [{{problem.constraints().center()|join(', ')}}];
{%- elif 'Rectangle' == problem.constraints().__class__.__name__ -%}
{%- if problem.constraints().xmin is not none -%}
const XMIN :Option<&[f64]> = Some(&[{{problem.constraints().xmin|join(', ')}}]);
{%- else -%}
const XMIN :Option<&[f64]> = None;
{%- endif -%}
{% if problem.constraints().xmax is not none %}
const XMAX :Option<&[f64]> = Some(&[{{problem.constraints().xmax|join(', ')}}]);
{%- else -%}
const XMAX :Option<&[f64]> = None;
{% endif %}
{%- endif %}


pub fn initialize_solver() -> PANOCCache {
    let problem_size = NonZeroUsize::new(NU).unwrap();
    let lbfgs_memory_size = NonZeroUsize::new(LBFGS_MEMORY).unwrap();
    let panoc_cache = PANOCCache::new(problem_size, TOLERANCE, lbfgs_memory_size);

    panoc_cache
}


// -- work in progress --
pub fn solve(p: &[f64], cache: &mut PANOCCache, u: &mut [f64]) -> Result<(), Error> {

    assert_eq!(p.len(), NP, "Wrong number of parameters (p)");
    assert_eq!(u.len(), NU, "Wrong number of decision variables (u)");

    let mut q_augmented_params = [0.0; NP + NCP];
    q_augmented_params[0..NP].copy_from_slice(p);


    //TODO: better error management (in closures)
	/* cost function, f(u; q) */
    let cost_function = |u: &[f64], q: &[f64], cost: &mut f64| -> Result<(), Error> {
        icasadi::icasadi_cost(u, q, cost);
        Ok(())
    };

    /* parametric gradient, df(u, q) */
    let gradient_function = |u: &[f64], q: &[f64], grad: &mut [f64]| -> Result<(), Error> {
        icasadi::icasadi_grad(u, q, grad);
        Ok(())
    };

	/* penalty-type constraints: c(u; p) */
    let penalty_constr_function =
    |u: &[f64], q: &[f64], constraints: &mut [f64]| -> Result<(), Error> {
        icasadi::icasadi_constraints_as_penalty(u, q, constraints);
        Ok(())
    };


    //Constraints...
{%- if problem.constraints() is none %}
    let bounds = NoConstraints::new();
{%- elif 'Ball2' == problem.constraints().__class__.__name__ %}
{%- if problem.constraints().center() is none %}
	let bounds = Ball2::new(None, {{problem.constraints().radius()}});
{%- else %}
	let bounds = Ball2::new(Some(&XC), {{problem.constraints().radius()}});
{%- endif %}
{%- elif 'Rectangle' == problem.constraints().__class__.__name__ %}
    let bounds = Rectangle::new(XMIN, XMAX);
{%- endif %}


    // Define homotopy problem
    //TODO: This constructor may not need to know NP...
    let mut homotopy_problem = continuation::HomotopyProblem::new(
        bounds,
        gradient_function,
        cost_function,
        penalty_constr_function,
    );

    // Do the following, only if there are some penalty-type constraints,
    // otherwise skip it
    if NCP > 0 {
        let idx_y: Vec<usize> = (NP..NP + NCP).collect();
        homotopy_problem.add_continuations(
            &idx_y[..],
            &[3.; NCP],
            &[0.; NCP],
            &[continuation::ContinuationMode::Geometric(PENALTY_WEIGHT_UPDATE_FACTOR); NCP],
        );
    }

    let mut homotopy_optimizer = continuation::HomotopyOptimizer::new(&homotopy_problem, cache)
        .with_constraint_tolerance(CONSTRAINTS_TOLERANCE)
        .with_max_outer_iterations(MAX_OUTER_ITERATIONS);

    homotopy_optimizer.solve(u, &q_augmented_params)
}
