//! # CasADi Rust interface
//!
//! This is a Rust interface to CasADi C functions.
//!
//! This is a `no-std` library (however, mind that the CasADi-generated code
//! requires `libm` to call math functions such as `sqrt`, `sin`, etc...) and
//! icallocator.c requires libstd to allocate memory using malloc
//!
//! ---
//!
//! Auto-generated header file
//! This file is part of OptimizationEngine
//! (see https://alphaville.github.io/optimization-engine/)
//!
//! Generated at: {{timestamp_created}}
//!

#![no_std]

/// Number of static parameters (this also includes penalty constraints)
pub const NUM_STATIC_PARAMETERS: usize = {{problem.dim_parameters() + problem.dim_constraints_penalty() or 0}};

/// Number of decision variables
pub const NUM_DECISION_VARIABLES: usize = {{problem.dim_decision_variables()}};

/// Number of ALM-type constraints (dimension of F1, i.e., n1)
pub const NUM_CONSTRAINTS_TYPE_ALM: usize = {{problem.dim_constraints_aug_lagrangian() or 0}};

/// Number of penalty constraints (dimension of F2, i.e., n2)
pub const NUM_CONSTAINTS_TYPE_PENALTY: usize = {{problem.dim_constraints_penalty() or 0}};

use libc::{c_double, c_int, c_longlong, c_void};

/// C interface (Function API exactly as provided by CasADi)
extern "C" {

    // -----------------------------------------------------------
    //  Main External (C) functions
    // -----------------------------------------------------------


    /// Gradient of the cost function, Df(u, p), generated by CasADi
    ///
    ///
    /// ## Arguments
    ///
    /// - `arg`: function arguemnts (u and p)
    /// - `casadi_results`:
    /// - `iw`: integer workspace (here: empty)
    /// - `w`: workspace (here: empty)
    /// - `mem`: memory (here, 0)
    fn {{build_config.grad_function_name  or 'grad_phi'}}(
        arg: *const *const c_double,
        casadi_results: *mut *mut c_double,
        iw: *mut c_longlong,
        w: *mut c_double,
        mem: *mut c_void,
    ) -> c_int;

    /// Penalty-related mapping, F1(u, p), generated by CasADi
    ///
    ///
    /// ## Arguments
    ///
    /// - `arg`: function arguemnts (u and p)
    /// - `casadi_results`:
    /// - `iw`: integer workspace (here: empty)
    /// - `w`: workspace (here: empty)
    /// - `mem`: memory (here, 0)
    fn {{build_config.alm_mapping_f1_function_name  or 'mapping_f1'}}(
        arg: *const *const c_double,
        casadi_results: *mut *mut c_double,
        iw: *mut c_longlong,
        w: *mut c_double,
        mem: *mut c_void,
    ) -> c_int;

    /// Penalty-related mapping, F2(u, p), generated by CasADi
    ///
    ///
    /// ## Arguments
    ///
    /// - `arg`: function arguemnts (u and p)
    /// - `casadi_results`:
    /// - `iw`: integer workspace (here: empty)
    /// - `w`: workspace (here: empty)
    /// - `mem`: memory (here, 0)
    fn {{build_config.constraint_penalty_function_name  or 'mapping_f2'}}(
        arg: *const *const c_double,
        casadi_results: *mut *mut c_double,
        iw: *mut c_longlong,
        w: *mut c_double,
        mem: *mut c_void,
    ) -> c_int;



    // -----------------------------------------------------------
    //  Workspace Length External (C) functions
    // -----------------------------------------------------------

    /// Workspace lengths of cost function
	fn allocated_{{build_config.grad_function_name  or 'grad_phi'}}_iwork() -> *mut c_longlong;
	fn allocated_{{build_config.grad_function_name  or 'grad_phi'}}_rwork() -> *mut c_double;
	fn allocated_{{build_config.alm_mapping_f1_function_name}}_iwork() -> *mut c_longlong;
	fn allocated_{{build_config.alm_mapping_f1_function_name}}_rwork() -> *mut c_double;
	fn allocated_{{build_config.constraint_penalty_function_name}}_iwork() -> *mut c_longlong;
	fn allocated_{{build_config.constraint_penalty_function_name}}_rwork() -> *mut c_double;

	fn init_{{build_config.id or '0'}}() -> c_int;
	fn destroy_{{build_config.id or '0'}}() -> c_int;

	fn cost_function(
        arg: *const *const c_double,
        casadi_results: *mut *mut c_double
    ) -> c_int;



} // END of extern C




// Initialisation
pub fn init() -> i32 {
    unsafe {
        return init_{{build_config.id or '0'}}();
    }
}


// Destruction
pub fn destroy() -> i32 {
    unsafe {
        return destroy_{{build_config.id or '0'}}();
    }
}

// -----------------------------------------------------------
//  *MAIN* API Functions in Rust
// -----------------------------------------------------------


///
/// Consume the cost function written in C
///
/// # Example
/// ```
/// fn tst_call_casadi_cost() {
///     let u = [1.0, 2.0, 3.0, -5.0, 1.0, 10.0, 14.0, 17.0, 3.0, 5.0];
///     let p = [1.0, -1.0];
///     let mut cost_value = 0.0;
///     icasadi::cost(&u, &p, &mut cost_value);
/// }
/// ```
///
/// # Panics
/// This method panics if the following conditions are not satisfied
///
/// - `u.len() == NUM_DECISION_VARIABLES`
/// - `static_params.len() == NUM_STATIC_PARAMETERS`
///
pub fn cost(u: &[f64], static_params: &[f64], cost_value: &mut f64) -> i32 {
    assert_eq!(u.len(), NUM_DECISION_VARIABLES);
    assert_eq!(static_params.len(), NUM_STATIC_PARAMETERS);

    let arguments = &[u.as_ptr(), static_params.as_ptr()];
    let cost = &mut [cost_value as *mut c_double];

    unsafe {
        cost_function(
            arguments.as_ptr(),
            cost.as_mut_ptr(),
        ) as i32
    }
}

///
/// Consume the Jacobian function written in C
///
/// # Example
/// ```
/// fn tst_call_casadi_cost() {
///     let u = [1.0, 2.0, 3.0, -5.0, 1.0, 10.0, 14.0, 17.0, 3.0, 5.0];
///     let p = [1.0, -1.0];
///     let mut jac = [0.0; 10];
///     icasadi::grad(&u, &p, &mut jac);
/// }
/// ```
///
/// # Panics
/// This method panics if the following conditions are not satisfied
///
/// - `u.len() == icasadi::num_decision_variables()`
/// - `static_params.len() == icasadi::num_static_parameters()`
/// - `cost_jacobian.len() == icasadi::num_decision_variables()`
///
pub fn grad(u: &[f64], static_params: &[f64], cost_jacobian: &mut [f64]) -> i32 {
    assert_eq!(u.len(), NUM_DECISION_VARIABLES);
    assert_eq!(cost_jacobian.len(), NUM_DECISION_VARIABLES);
    assert_eq!(static_params.len(), NUM_STATIC_PARAMETERS);

    let arguments = &[u.as_ptr(), static_params.as_ptr()];
    let grad = &mut [cost_jacobian.as_mut_ptr()];

    unsafe {
        {{build_config.grad_function_name  or 'grad_phi'}}(
            arguments.as_ptr(),
            grad.as_mut_ptr(),
            allocated_{{build_config.grad_function_name  or 'grad_phi'}}_iwork(),
            allocated_{{build_config.grad_function_name  or 'grad_phi'}}_rwork(),
            0 as *mut c_void,
        ) as i32
    }
}


/// Consume mapping F1, which has been generated by CasADi
///
/// This is a wrapper function
///
/// ## Arguments
///
/// - `u`: (in) decision variables
/// - `p`: (in) vector of parameters
/// - `f1`: (out) value F2(u, p)
///
/// ## Returns
///
/// Returns `0` iff the computation is successful
///
pub fn mapping_f1(
    u: &[f64],
    static_params: &[f64],
    f1: &mut [f64],
) -> i32 {
    assert_eq!(u.len(), NUM_DECISION_VARIABLES);
    assert_eq!(static_params.len(), NUM_STATIC_PARAMETERS);
    assert!(f1.len() == NUM_CONSTAINTS_TYPE_PENALTY ||
            NUM_CONSTAINTS_TYPE_PENALTY == 0);

    let arguments = &[u.as_ptr(), static_params.as_ptr()];
    let constraints = &mut [f1.as_mut_ptr()];

    unsafe {
         {{build_config.alm_mapping_f1_function_name  or 'mapping_f1'}}(
            arguments.as_ptr(),
            constraints.as_mut_ptr(),
            allocated_{{build_config.alm_mapping_f1_function_name}}_iwork(),
            allocated_{{build_config.alm_mapping_f1_function_name}}_rwork(),
            0 as *mut c_void,
        ) as i32
    }
}

/// Consume mapping F2, which has been generated by CasADi
///
/// This is a wrapper function
///
/// ## Arguments
///
/// - `u`: (in) decision variables
/// - `p`: (in) vector of parameters
/// - `f2`: (out) value F2(u, p)
///
/// ## Returns
///
/// Returns `0` iff the computation is successful
pub fn mapping_f2(
    u: &[f64],
    static_params: &[f64],
    f2: &mut [f64],
) -> i32 {
    assert_eq!(u.len(), NUM_DECISION_VARIABLES);
    assert_eq!(static_params.len(), NUM_STATIC_PARAMETERS);
    assert!(f2.len() == NUM_CONSTAINTS_TYPE_PENALTY ||
            NUM_CONSTAINTS_TYPE_PENALTY == 0);

    let arguments = &[u.as_ptr(), static_params.as_ptr()];
    let constraints = &mut [f2.as_mut_ptr()];

    unsafe {
        {{build_config.constraint_penalty_function_name  or 'constraints_penalty'}}(
            arguments.as_ptr(),
            constraints.as_mut_ptr(),
            allocated_{{build_config.constraint_penalty_function_name}}_iwork(),
			allocated_{{build_config.constraint_penalty_function_name}}_rwork(),
            0 as *mut c_void,
        ) as i32
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn tst_num_static() {
        let _np = NUM_STATIC_PARAMETERS;
    }

    #[test]
    fn tst_num_decision_var() {
        let _nu = NUM_DECISION_VARIABLES;
    }

    #[test]
    fn tst_initialise() {
	assert_eq!(0, init());
	assert_eq!(0, init());
	assert_eq!(0, destroy());
    }

}
